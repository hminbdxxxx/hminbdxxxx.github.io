<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>对 HTTP2 协议的一些理解</title><link rel=stylesheet href=/css/style.css></head><body><header>================<br>== <a href=https://hminbdxxxx.github.io>hminbdxxxx</a> ==<br>================<div style=float:right>hminbdxxx的记录</div><br><p><nav><a href=/><b>Start</b></a>.
<a href=/posts><b>All posts</b></a>.
<a href=/about><b>About</b></a>.
<a href=/tags><b>Tags</b></a>.</nav></p></header><main><article><h1>对 HTTP2 协议的一些理解</h1><b><time>2021-08-14 10:10:00</time></b>
<a href=/tags/network>network</a>
<a href=/tags/notes>notes</a><div><p>本文记录阅读 HTTP2-explained 过程中，对 HTTP 协议的一些理解。</p><h1 id=http-1x-的缺陷>HTTP 1.x 的缺陷</h1><h2 id=过于庞大太多的细节选项>过于庞大，太多的细节选项</h2><p>HTTP 1.1 有太多的细节选项，却又很少被使用，理解起来也非常困难。（不要过度设计）</p><h2 id=队头阻塞>队头阻塞</h2><p>HTTP 1.0 使用TCP短连接，完成一次 HTTP 请求响应就会关闭对应的 TCP 连接，所以会有很大的 TCP 连接建立关闭开销。HTTP 1.1 增加了一个 Head 选项 <code>Connection:Keep-Alive</code>，默认复用 TCP 连接。同时，客户端支持在一个 TCP 连接上一次发送多个 HTTP 请求，不需要等待上一个请求的响应完成，这称为<code>HTTP pipelining</code>。</p><p>但是这只是针对客户端，服务端还是需要按顺序将一个一个请求处理完再返回，因为客户端收到响应并不能从响应得知它属于哪一个请求，所以还是只能按顺序处理，如果前一个请求处理很慢，那么后面的请求就都会受影响。一个解决办法就是另起一个 TCP 连接，但是另起 TCP 连接又会引入连接管理的开销。这就是 HTTP 1 的队头阻塞问题。</p><h1 id=http-2-的主要改进点>HTTP 2 的主要改进点</h1><h2 id=二进制帧与多路复用>二进制帧与多路复用</h2><p>HTTP2 使用帧来承载 HTTP 报文，帧是二进制的（基于文本，帧的实现会比较复杂），并且都有这些公共字段：Type, Length, Flags, Stream Identifier 和 frame payload。
Stream ID 标识这个帧属于哪一个 HTTP2 流，有了这个标识，HTTP2 连接就可以并发承载多个流，相对于 HTTP1 在一个连接上只能等待上一个请求响应完成才能进行下一个，效率高了很多。</p><h2 id=头部压缩>头部压缩</h2><p>HTTP 是无状态的协议，所以每个 HTTP 请求响应都必须能独立完成，需要携带所有信息。所以在一些大量资源请求的场景，使用 HTTP1 时，会有大量重复的 HEADER 信息传输。 HTTP2 设计引入了 HAPCK 进行头部压缩，这是一个专门设计的算法。粗略浅显地了解，头部压缩包含一个静态表和动态表，静态表是只读的，包含经常出现的 HEADER 字段，动态表是动态的有上下文的，需要通信两端共同维护，HPACK 主要通过这两个表对 HEADER 进行压缩,减少冗余信息的传输。因此 HTTP2 鼓励连接复用，因为复用连接会让动态表更加完整，提高效率。</p><h2 id=服务端推送>服务端推送</h2><p>访问一个网页，一般都需要加载各种CSS、JS或者图片等静态资源。所以当客户端访问一个资源时，服务端很有可能知道客户端还需要什么其它资源。服务端推送就是指服务端可以在客户端发送请求前，主动将资源推送给客户端，客户端可以将这个资源放入缓存以备后续请求，客户端也可以选择关闭这个功能。</p><h2 id=无状态语义的理解>无状态语义的理解</h2><p>HTTP2 引入了 HAPCK 进行头部压缩，HAPCK 需要维护动态表，明显是一个有状态的协议，那 HTTP2 还是一个无状态协议吗？
StackOverflow 上有一个问题和我有同样的疑问，这个问题有两个回答，一个认为 HTTP2 还是无状态，另一个认为 HTTP2 有状态。
读了两个回答和回答下面的评论，个人认为 HTTP2 仍然是无状态协议：对于 HTTP 协议来说，有无状态的区别在于是否请求能够独立完成，不依赖于上一个请求响应的状态。HPACK 维护的动态表状态只是提高了传输效率，动态表完整的情况比不完整的情况需要传输的重复信息更少，效率更高，并不会改变 HTTP2 的语义。同样的道理，有一种说法是：HTTP 底层依赖的是 TCP 连接，TCP 协议显然是有状态的，但是并不妨碍 HTTP 是一个无状态协议。</p></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/posts/http2-explained-notes/>对 HTTP2 协议的一些理解</a></li><li><a href=/posts/myfirstpost/>test</a></li></ul></div></div></aside><footer><p>&copy; 2021 <a href=https://hminbdxxxx.github.io><b>hminbdxxxx</b></a>.
<a href=https://github.com/hminbdxxxx><b>Github</b></a>.</p></footer></body></html>